#!/bin/bash
# TODO: make faster

source /usr/lib/libui.sh

# for some pairs of known files, on manual inspection they look the same. maybe a bit error or something...
function files_diff_but_really_same () {
    md5sum=$(md5sum "$1" "$2" | cut -d' ' -f1 | sort | md5sum | cut -d' ' -f1)
    [ $md5sum == 7d253cbdb83e9532c3be858481104614 ]
}

function files_same () {
    diff -q "$1" "$2" >/dev/null
}

source "$(dirname "$0")"/config.sh

path_prefix="$iphoto_out/$(basename "$iphoto_in")_"
echo "cleaning old incompleted dirs.. ('${path_prefix}*.auto_generated.new')"
if egrep -q "[[:space:]]" <<< "$path_prefix"; then
    die_error "whitespace in path prefix: $path_prefix"
fi

rm -rvf "${path_prefix}"*.auto_generated.new
echo "processing files in $iphoto_in (symlinking to $path_prefix<device>.auto_generated.new)"
while read file; do
    set -o pipefail # normally i would just use $PIPESTATUS but that seems to not work in a subshell
    # unfortunately, the output of the exiv2 command can contain bogus (trailing) whitespace..
    device=$(exiv2 -g Exif.Image.Model -P v "$file" | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//' -e 's# #_#g')
    ret=$?
    # it exit(253)'s on success. wtf.
    if [ $ret -gt 0 -a $ret -ne 253 ]; then
        # get lowercase ext
        ext="${file##*.}"; ext="${ext,,}"
        if [ "$ext" = 'mov' ] || [ "$ext" = 'mp4' ]; then
            # this is to be expected. silently ignore
            true
        else
            echo "warning: skipping '$file', because exiv2 couldn't get the model from it"
            continue
        fi
    fi
    if [ -z "$device" ]; then
        device='unknown'
    fi
    dir="$path_prefix${device}.auto_generated.new"
    mkdir -p "$dir" || die_error "Can't mkdir -p '$dir'"
    cd "$dir" || die_error "Can't cd '$dir'"
    base="$(basename "$file")"
    new_base="$base"
    if [ -e "$base" ]; then
        if files_same "$base" "$file"; then
            # this is just one of the (sometimes many) dupes within the iphoto library, don't create a new link
            new_base=
        elif files_diff_but_really_same "$base" "$file"; then
            # don't create a new link for a few known cases
            new_base=
        else
            ext="${base##*.}"
            base_no_ext="${base%.*}"
            for i in {1..10000}; do
                new_base="${base_no_ext}_dup$i.$ext"
                # we tried all existing dup files, this one is not taken yet, so use it.
                [ ! -f "$new_base" ] && break
                # if this dup file is the same file as $file, we don't need to create a new link
                files_same "$new_base" "$file" && new_base= && break
            done
            if [ -n "$new_base" ]; then
                # we went through the entire loop, all dup files exist
                [ ! -f "$new_base" ] || die_error "way too many different files trying to bring $file into $dir/${base_no_ext}*.$ext"
                echo "warning: saving dupfile $new_base for $file, because $base already existed"
            fi
        fi
    fi
    [ -n "$new_base" ] && ln -r -s "$file" "$new_base"
    cd - > /dev/null || die_error "Can't cd back after going into '$dir'"
done < <(find "$iphoto_in" -type f | grep -v AppleDouble)
echo "finishing up new directories.."
cd "$iphoto_out" || die_error "Can't cd '$iphoto_out'"
for dir_old in *.auto_generated.new; do
    dir_new="${dir_old/.auto_generated.new}"
    rm -rfv "$dir_new" || die_error "Can't rm '$dir_new'"
    mv -v "$dir_old" "$dir_new" || die_error "Can't mv '$dir_old' '$dir_new'"
    echo "generated by $@ on $(date)" > $dir_new/.auto-generated || die_error "Can't put .auto-generated notice in $dir_new"
done
echo "done"
